todo TCP 粘包/半包发生的原因

由于 TCP 协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会
维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发
往服务器，但是如果发送的网络数据包太小，那么他本身会启用 Nagle 算法（可配置是否启
用）对较小的数据包进行合并（基于此，TCP 的网络延迟要 UDP 的高些）然后再发送（超
时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪
些数据包是客户端自己分开发送的，这样产生了粘包；服务器在接收到数据库后，放到缓冲
区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个
数据包的情况，造成粘包现象

UDP：本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），他不会对
数据包进行合并发送（也就没有 Nagle 算法之说了），他直接是一端发送什么数据，直接就
发出去了，既然他不会对数据合并，每一个数据包都是完整的（数据+UDP 头+IP 头等等发一
次数据封装一次）也就没有粘包一说了。

todo 解决粘包半包问题

由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重
组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，
可以归纳如下。
（1） 在包尾增加分割符，比如回车换行符进行分割，例如 FTP 协议；
（回车换行符进行分割）和（自定义分割符）
（2）消息定长，例如每个报文的大小为固定长度 200 字节，如果不够，空位补空格；
（3）将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）
的字段，通常设计思路为消息头的第一个字段使用 int32 来表示消息的总长度，使用
LengthFieldBasedFrameDecoder，后面会有详细说明和使用。

fixed       定长
linebase    换行符
delimiter   自定义分隔符
bodyheader  消息头和消息体（这种方法最佳）